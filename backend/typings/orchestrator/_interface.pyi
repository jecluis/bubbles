# type: ignore
import datetime
import enum
from ceph.deployment import inventory
from ceph.deployment.drive_group import DriveGroupSpec as DriveGroupSpec
from ceph.deployment.hostspec import HostSpec
from ceph.deployment.service_spec import IngressSpec as IngressSpec, IscsiServiceSpec as IscsiServiceSpec, NFSServiceSpec as NFSServiceSpec, RGWSpec as RGWSpec, ServiceSpec
from collections import OrderedDict
from mgr_module import HandleCommandResult, MgrModule as MgrModule
from typing import Any, Callable, Dict, Iterator, List, Optional, Sequence, Tuple, TypeVar, Union

class Protocol: ...

logger: Any
T = TypeVar('T')
FuncT = TypeVar('FuncT', bound=Callable[..., Any])

class OrchestratorError(Exception):
    errno: Any
    event_subject: Any
    def __init__(self, msg: str, errno: int = ..., event_kind_subject: Optional[Tuple[str, str]] = ...) -> None: ...

class NoOrchestrator(OrchestratorError):
    def __init__(self, msg: str = ...) -> None: ...

class OrchestratorValidationError(OrchestratorError): ...

def set_exception_subject(kind: str, subject: str, overwrite: bool = ...) -> Iterator[None]: ...
def handle_exception(prefix: str, perm: str, func: FuncT) -> FuncT: ...
def handle_orch_error(f: Callable[..., T]) -> Callable[..., OrchResult[T]]: ...

class InnerCliCommandCallable:
    def __call__(self, prefix: str) -> Callable[[FuncT], FuncT]: ...

class CLICommandMeta(type):
    def __init__(cls, name: str, bases: Any, dct: Any): ...

class OrchResult:
    result: Any
    serialized_exception: Any
    exception_str: str
    def __init__(self, result: Optional[T], exception: Optional[Exception] = ...) -> None: ...
    def set_exception(self, e: Optional[Exception]) -> None: ...
    def result_str(self) -> str: ...

def raise_if_exception(c: OrchResult[T]) -> T: ...

class Orchestrator:
    def is_orchestrator_module(self) -> bool: ...
    def available(self) -> Tuple[bool, str, Dict[str, Any]]: ...
    def get_feature_set(self) -> Dict[str, dict]: ...
    def cancel_completions(self) -> None: ...
    def pause(self) -> None: ...
    def resume(self) -> None: ...
    def add_host(self, host_spec: HostSpec) -> OrchResult[str]: ...
    def remove_host(self, host: str) -> OrchResult[str]: ...
    def drain_host(self, hostname: str) -> OrchResult[str]: ...
    def update_host_addr(self, host: str, addr: str) -> OrchResult[str]: ...
    def get_hosts(self) -> OrchResult[List[HostSpec]]: ...
    def add_host_label(self, host: str, label: str) -> OrchResult[str]: ...
    def remove_host_label(self, host: str, label: str) -> OrchResult[str]: ...
    def host_ok_to_stop(self, hostname: str) -> OrchResult: ...
    def enter_host_maintenance(self, hostname: str, force: bool = ...) -> OrchResult: ...
    def exit_host_maintenance(self, hostname: str) -> OrchResult: ...
    def get_inventory(self, host_filter: Optional[InventoryFilter] = ..., refresh: bool = ...) -> OrchResult[List[InventoryHost]]: ...
    def describe_service(self, service_type: Optional[str] = ..., service_name: Optional[str] = ..., refresh: bool = ...) -> OrchResult[List[ServiceDescription]]: ...
    def list_daemons(self, service_name: Optional[str] = ..., daemon_type: Optional[str] = ..., daemon_id: Optional[str] = ..., host: Optional[str] = ..., refresh: bool = ...) -> OrchResult[List[DaemonDescription]]: ...
    def apply(self, specs: Sequence[GenericSpec], no_overwrite: bool = ...) -> List[str]: ...
    def plan(self, spec: Sequence[GenericSpec]) -> OrchResult[List]: ...
    def remove_daemons(self, names: List[str]) -> OrchResult[List[str]]: ...
    def remove_service(self, service_name: str) -> OrchResult[str]: ...
    def service_action(self, action: str, service_name: str) -> OrchResult[List[str]]: ...
    def daemon_action(self, action: str, daemon_name: str, image: Optional[str] = ...) -> OrchResult[str]: ...
    def create_osds(self, drive_group: DriveGroupSpec) -> OrchResult[str]: ...
    def apply_drivegroups(self, specs: List[DriveGroupSpec]) -> OrchResult[List[str]]: ...
    def set_unmanaged_flag(self, unmanaged_flag: bool, service_type: str = ..., service_name: Optional[str] = ...) -> HandleCommandResult: ...
    def preview_osdspecs(self, osdspec_name: Optional[str] = ..., osdspecs: Optional[List[DriveGroupSpec]] = ...) -> OrchResult[str]: ...
    def remove_osds(self, osd_ids: List[str], replace: bool = ..., force: bool = ...) -> OrchResult[str]: ...
    def stop_remove_osds(self, osd_ids: List[str]) -> OrchResult: ...
    def remove_osds_status(self) -> OrchResult: ...
    def blink_device_light(self, ident_fault: str, on: bool, locations: List[DeviceLightLoc]) -> OrchResult[List[str]]: ...
    def zap_device(self, host: str, path: str) -> OrchResult[str]: ...
    def add_daemon(self, spec: ServiceSpec) -> OrchResult[List[str]]: ...
    def apply_mon(self, spec: ServiceSpec) -> OrchResult[str]: ...
    def apply_mgr(self, spec: ServiceSpec) -> OrchResult[str]: ...
    def apply_mds(self, spec: ServiceSpec) -> OrchResult[str]: ...
    def apply_rgw(self, spec: RGWSpec) -> OrchResult[str]: ...
    def apply_ingress(self, spec: IngressSpec) -> OrchResult[str]: ...
    def apply_rbd_mirror(self, spec: ServiceSpec) -> OrchResult[str]: ...
    def apply_nfs(self, spec: NFSServiceSpec) -> OrchResult[str]: ...
    def apply_iscsi(self, spec: IscsiServiceSpec) -> OrchResult[str]: ...
    def apply_prometheus(self, spec: ServiceSpec) -> OrchResult[str]: ...
    def apply_node_exporter(self, spec: ServiceSpec) -> OrchResult[str]: ...
    def apply_crash(self, spec: ServiceSpec) -> OrchResult[str]: ...
    def apply_grafana(self, spec: ServiceSpec) -> OrchResult[str]: ...
    def apply_alertmanager(self, spec: ServiceSpec) -> OrchResult[str]: ...
    def apply_cephadm_exporter(self, spec: ServiceSpec) -> OrchResult[str]: ...
    def upgrade_check(self, image: Optional[str], version: Optional[str]) -> OrchResult[str]: ...
    def upgrade_start(self, image: Optional[str], version: Optional[str]) -> OrchResult[str]: ...
    def upgrade_pause(self) -> OrchResult[str]: ...
    def upgrade_resume(self) -> OrchResult[str]: ...
    def upgrade_stop(self) -> OrchResult[str]: ...
    def upgrade_status(self) -> OrchResult[UpgradeStatusSpec]: ...
    def upgrade_available(self) -> OrchResult: ...
GenericSpec = Union[ServiceSpec, HostSpec]

def json_to_generic_spec(spec: dict) -> GenericSpec: ...
def daemon_type_to_service(dtype: str) -> str: ...
def service_to_daemon_types(stype: str) -> List[str]: ...

KNOWN_DAEMON_TYPES: List[str]

class UpgradeStatusSpec:
    in_progress: bool
    target_image: Any
    services_complete: Any
    progress: Any
    message: str
    def __init__(self) -> None: ...

def handle_type_error(method: FuncT) -> FuncT: ...

class DaemonDescriptionStatus(enum.IntEnum):
    error: int
    stopped: int
    running: int

class DaemonDescription:
    hostname: Any
    container_id: Any
    container_image_id: Any
    container_image_name: Any
    container_image_digests: Any
    daemon_type: Any
    daemon_id: Any
    rank: Any
    rank_generation: Any
    version: Any
    status: Any
    status_desc: Any
    last_refresh: Any
    created: Any
    started: Any
    last_configured: Any
    last_deployed: Any
    osdspec_affinity: Any
    events: Any
    memory_usage: Any
    memory_request: Any
    memory_limit: Any
    ports: Any
    ip: Any
    deployed_by: Any
    is_active: Any
    def __init__(self, daemon_type: Optional[str] = ..., daemon_id: Optional[str] = ..., hostname: Optional[str] = ..., container_id: Optional[str] = ..., container_image_id: Optional[str] = ..., container_image_name: Optional[str] = ..., container_image_digests: Optional[List[str]] = ..., version: Optional[str] = ..., status: Optional[DaemonDescriptionStatus] = ..., status_desc: Optional[str] = ..., last_refresh: Optional[datetime.datetime] = ..., created: Optional[datetime.datetime] = ..., started: Optional[datetime.datetime] = ..., last_configured: Optional[datetime.datetime] = ..., osdspec_affinity: Optional[str] = ..., last_deployed: Optional[datetime.datetime] = ..., events: Optional[List[OrchestratorEvent]] = ..., is_active: bool = ..., memory_usage: Optional[int] = ..., memory_request: Optional[int] = ..., memory_limit: Optional[int] = ..., service_name: Optional[str] = ..., ports: Optional[List[int]] = ..., ip: Optional[str] = ..., deployed_by: Optional[List[str]] = ..., rank: Optional[int] = ..., rank_generation: Optional[int] = ...) -> None: ...
    def get_port_summary(self) -> str: ...
    def name(self) -> str: ...
    def matches_service(self, service_name: Optional[str]) -> bool: ...
    def service_id(self) -> str: ...
    def service_name(self) -> str: ...
    def to_json(self) -> dict: ...
    def to_dict(self) -> dict: ...
    @classmethod
    def from_json(cls, data: dict) -> DaemonDescription: ...
    def __copy__(self) -> DaemonDescription: ...
    @staticmethod
    def yaml_representer(dumper: yaml.SafeDumper, data: DaemonDescription) -> Any: ...

class ServiceDescription:
    container_image_id: Any
    container_image_name: Any
    service_url: Any
    size: Any
    running: Any
    last_refresh: Any
    created: Any
    deleted: Any
    spec: Any
    events: Any
    virtual_ip: Any
    ports: Any
    def __init__(self, spec: ServiceSpec, container_image_id: Optional[str] = ..., container_image_name: Optional[str] = ..., service_url: Optional[str] = ..., last_refresh: Optional[datetime.datetime] = ..., created: Optional[datetime.datetime] = ..., deleted: Optional[datetime.datetime] = ..., size: int = ..., running: int = ..., events: Optional[List[OrchestratorEvent]] = ..., virtual_ip: Optional[str] = ..., ports: List[int] = ...) -> None: ...
    def service_type(self) -> str: ...
    def get_port_summary(self) -> str: ...
    def to_json(self) -> OrderedDict: ...
    def to_dict(self) -> OrderedDict: ...
    @classmethod
    def from_json(cls, data: dict) -> ServiceDescription: ...
    @staticmethod
    def yaml_representer(dumper: yaml.SafeDumper, data: ServiceDescription) -> Any: ...

class InventoryFilter:
    labels: Any
    hosts: Any
    def __init__(self, labels: Optional[List[str]] = ..., hosts: Optional[List[str]] = ...) -> None: ...

class InventoryHost:
    name: Any
    addr: Any
    devices: Any
    labels: Any
    def __init__(self, name: str, devices: Optional[inventory.Devices] = ..., labels: Optional[List[str]] = ..., addr: Optional[str] = ...) -> None: ...
    def to_json(self) -> dict: ...
    @classmethod
    def from_json(cls, data: dict) -> InventoryHost: ...
    @classmethod
    def from_nested_items(cls, hosts: List[dict]) -> List[InventoryHost]: ...
    @staticmethod
    def get_host_names(hosts: List[InventoryHost]) -> List[str]: ...
    def __eq__(self, other: Any) -> bool: ...

class DeviceLightLoc: ...

class OrchestratorEvent:
    INFO: str
    ERROR: str
    regex_v1: Any
    created: Any
    kind: Any
    subject: Any
    level: Any
    message: Any
    def __init__(self, created: Union[str, datetime.datetime], kind: str, subject: str, level: str, message: str) -> None: ...
    def kind_subject(self) -> str: ...
    def to_json(self) -> str: ...
    def to_dict(self) -> dict: ...
    @classmethod
    def from_json(cls, data: str) -> OrchestratorEvent: ...
    def __eq__(self, other: Any) -> bool: ...

class OrchestratorClientMixin(Orchestrator):
    def set_mgr(self, mgr: MgrModule) -> None: ...
